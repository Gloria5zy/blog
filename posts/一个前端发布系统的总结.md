## 引言

笔者本科是在成都的一所双非大学念的，四年前大四的找工作时候，由于没什么好公司愿意到我们学校招人，于是我每天到隔壁985电子科技大学蹲点混宣讲会，经过了一个多月的不要脸的摸爬滚打，终于收到杭州的一家独角兽公司的offer，月薪8K，贼开心，不久之后，我就到了这家公司上班。

## 项目初态

这家独角兽公司主要是toB的业务，对于前端的需求来说，项目是一个非常大的管理平台，前端架构也非常非常古老，前后端并没有分离，整体架构大体是这样的。

![image-20201119205537278](/Users/baidu/Library/Application Support/typora-user-images/image-20201119205537278.png)

一个非常大的Java项目，用的阿里开源的JavaWeb框架webx，然后用了类似JSP之类的东西，也就是velocity模板来渲染页面，而前端需要编写jQuery脚本和CSS脚本来完成功能，编写完后将脚本扔到Webx的静态资源目录，然后在velocity中引入对应的脚本。

可以看到，这种模式对于现在的我们来说，非常有年代感，经典的MVC模式，对当时的我们来说，痛点也很明显：前端在开发过程中，必须启动一个后端项目，而随着后端项目的越来越庞大，每次启动都至少需要四五分钟，开发体验极差。为什么必须要启动后端项目？一个是项目开发依赖于velocity渲染的html结构，第二是因为项目请求的数据接口依赖于后端项目。

## 前端变革

为了解决开发体验的问题，我们想到了个两全其美的办法，既可以更新技术栈，又可以提升开发体验。那就是对于老的、已完成的页面，先放着不管，而对于新的需求页面，使用React进行工程化编写。

对于velocity渲染的html依赖问题，我们只需要约定好在velocity中渲染对应ID的DOM节点，然后在React项目中ReactDOM.render对应ID的节点就可以，这样就可以解决渲染后端项目的html渲染依赖问题。

而接口依赖问题很容易解决，可以通过mock接口解决，也可以在webpack中配置代理，将请求代理到后端的测试机器，这样就可以解决后端项目启动的问题。

而在项目发布时，将React项目的webpack的output目录指定到Webx的静态资源目录，然后在velicity中引入对应的编译结果就可以。比如现在有一个新的页面A，那么velocity中的模板是这样的：

```html
<link rel="stylesheet" href="/static/xxx_module/page/pageA.css" />
<script src="/static/xxx_module/page/pageA.js"></script>

<div id="pageA"></div>
```

而React的项目是这样的

```js
import React from 'react';
import React from 'react-dom';
import App from './App';

// 在开发时，声明一个带ID为pageA的空页面就可以
const container = document.getElementById('pageA');

ReactDom.render(<App />, container);
```

webpack项目配置：

```js
const path = require('path');

module.exports = {
  entry: {
    pageA: './src/main.js'
  },
  output: {
    path: path.resolve('后端项目路径', 'static', 'xxx_module', 'page'),
    filename: '[name].js'
  },
  // ...其他配置
}
```

此时，项目的架构如下：

![image-20201119205628118](/Users/baidu/Library/Application Support/typora-user-images/image-20201119205628118.png)







痛点



目标

难点

方案

