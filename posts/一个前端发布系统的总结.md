## 引言

笔者本科是在成都的一所双非大学念的，四年前大四的找工作时候，由于没什么好公司愿意到我们学校招人，于是我每天到隔壁985电子科技大学蹲点混宣讲会，经过了一个多月的不要脸的摸爬滚打，终于收到杭州的一家独角兽公司的offer，月薪8K，贼开心，不久之后，我就到了这家公司上班。

## 项目初态

这家独角兽公司主要是toB的业务，对于前端的需求来说，项目是一个非常大的管理平台，当时前端架构也非常非常古老，前后端并没有分离，整体架构大体是这样的。

![image-20201119205537278](/Users/baidu/Library/Application Support/typora-user-images/image-20201119205537278.png)

一个非常大的Java项目，用的阿里开源的JavaWeb框架webx，然后用了类似JSP之类的东西，也就是velocity模板来渲染页面，而前端需要编写jQuery脚本和CSS脚本来完成功能，这些脚本放在Webx的静态资源目录，在velocity模板中引入对应的脚本。

可以看到，这种模式对于现在的我们来说，非常有年代感，经典的MVC模式，缺点很明显。

* 前端代码在velocity模板中与部分后端逻辑混杂在一起，前端依赖后端渲染HTML，使得前后端代码有着很强的耦合性。
* 前端需要学习Java的模板引擎velocity语法，增加了前端学习的成本。
* 每次前端出现问题需要修改发布，即使后端没有任何更新，都必须伴随一次后端服务的发布，增加了出问题的可能。

由于项目相对来说已经比较成熟了，所有内容推倒重做是不可能的，而且当时前端在公司的地位非常的低，没有影响力，老板是不会允许前端乱搞的，所以，只能一步一步的想办法，改变现状。

## 前端第一次改造

对当时的我们来说，最大的痛点是前端在开发过程中，必须启动一个后端项目，而随着后端项目的越来越庞大，每次启动都至少需要四五分钟，开发体验极差。为什么必须要启动后端项目？一个是项目开发依赖于velocity渲染的html结构，第二是因为项目请求的数据接口依赖于后端项目。

为了解决开发体验的问题，我们想到了个两全其美的办法，既可以更新技术栈，又可以提升开发体验。那就是对于老的、已完成的页面，先放着不管，而对于新的需求页面，使用React进行工程化编写。

对于velocity渲染的html依赖问题，我们只需要约定好在velocity中渲染对应ID的DOM节点和初始化数据，然后在React项目中ReactDOM.render对应ID的节点并将初始化数据传递进去，这样就可以解决渲染后端项目的html渲染依赖问题。

而接口依赖问题很容易解决，可以通过mock接口解决，也可以在webpack中配置代理，将请求代理到后端的测试机器，这样就可以解决后端项目启动的问题。

而在项目发布时，将React项目的webpack的output目录指定到Webx的静态资源目录，然后在velicity中引入对应的编译结果就可以。比如现在有一个新的页面A，那么velocity中的模板是这样的：

```html
<link rel="stylesheet" href="/static/xxx_module/page/pageA.css?v=hash" />
<script src="/static/xxx_module/page/pageA.js?v=hash"></script>
<script>
  var _velocity_init_data_ = {
    // 渲染velocity数据
  };
</script>
<div id="pageA"></div>
```

而React的项目是这样的

```jsx
import React from 'react';
import React from 'react-dom';
import App from './App';

// 在开发时，声明一个带ID为pageA的空页面就可以
const container = document.getElementById('pageA');
const initData = window._velocity_init_data_;

ReactDom.render(<App initData={initData}/>, container);
```

webpack项目配置：

```js
const path = require('path');

module.exports = {
  entry: {
    pageA: './src/main.js'
  },
  output: {
    path: path.resolve('后端项目路径', 'static', 'xxx_module', 'page'),
    filename: '[name].js' // 将编译产出设置为pageA.js
  },
  // ...其他配置
}
```

此时，项目的架构如下：

![image-20201119205628118](/Users/baidu/Library/Application Support/typora-user-images/image-20201119205628118.png)

可以看到，将页面使用React工程化编写以后，前端代码与后端代码的耦合性大大降低了，后端只需要为前端提供初始化数据，前端可使用初始化数据完成相应的页面渲染。

## 前端第二次改造

随着公司业务的发展，整个后端项目越来越庞大，项目的单次更新部署至少都需要二三十分钟，而且由于业务场景要求，后端项目必须提升其高可用性和稳定性，这使得后端不得不将项目拆分，将各个模块各自单独开发，并且根据其访问情况，单独部署不同的机器、容器数量。这样的模块拆分，可以理解为后端项目在想微服务架构演进，各个模块有各自的路由，它们之间内部会通过http、rpc或者kafka进行通信。而当时前端影响力也并不大，以至于当时错过在后端项目拆分过程中的可以接过路由让前端管理的机会。

在后端向微服务架构演进的过程中，前端也迫不得已变成了一个微前端架构，由于公司没有前端架构，所以由当时开发这部分的前端拍脑袋定了一个iframe的方案。

页面情况大体是这样，平台有一个主入口路由，这个路由渲染页面左侧的菜单栏和右侧的内容区域，内容区域由iframe根据左侧的菜单的选中项来加载不同模块的页面。

